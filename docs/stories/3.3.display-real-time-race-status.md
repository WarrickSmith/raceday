# Story 3.3: Display real-time race status

**Status**: Approved

**As a** user  
**I want** to see the status of each race (Open, Closed, Running, Finalized) update in real-time on the dashboard  
**So that** I know which races are active.

## Acceptance Criteria

1. Status updates occur in real-time (<2s latency).
2. Status is visually clear and accessible.
3. Status matches backend values.

## Dev Notes

### Previous Story Insights

**Story 3.2 Foundation [Source: Story 3.2]:**

- RaceCard component already created with race status display capability
- RacesList component handles races within expanded meetings
- useRacesForMeeting hook established for race data fetching
- Real-time subscription already established in useRealtimeMeetings hook for races collection
- Race status enum and validation already implemented in races service
- Performance optimization with React.memo() and caching already in place

**Existing Components Available:**

- `client/src/components/dashboard/RaceCard.tsx` - Race display component with status field
- `client/src/components/dashboard/RacesList.tsx` - Container for races within meetings
- `client/src/hooks/useRealtimeMeetings.tsx` - Real-time hook already subscribes to races collection
- `client/src/hooks/useRacesForMeeting.tsx` - Race fetching hook with caching
- `client/src/services/races.ts` - Race data service with status validation and color helpers
- `client/src/types/meetings.ts` - TypeScript interfaces including Race interface

### Data Polling Architecture

**Appwrite Functions Data Flow [Source: server/appwrite.json + server functions]:**

- **race-data-poller**: Scheduled every 5 minutes (`*/5 * * * *`) for baseline polling within 1-hour window
- **single-race-poller**: HTTP-triggered function for high-frequency polling of specific races
- **Daily import pipeline**: daily-meetings → daily-races → comprehensive data setup

**Real-time Update Flow:**

1. **NZTAB API** → **Appwrite Functions** (server-side node-appwrite SDK)
2. **Appwrite Database** updates → **Real-time subscriptions** (client-side appwrite web SDK)
3. **Client Components** receive updates via existing `useRealtimeMeetings` hook

**High-Frequency Polling Strategy [Source: server/single-race-poller/src/main.js]:**

- Client can trigger `single-race-poller` function for races approaching start time
- Recommended approach: Next.js Server Actions with Appwrite node.js SDK
- Function updates database → real-time subscriptions notify clients
- No direct API polling from client-side (security and rate limiting)

### Data Models

**Race Status Schema [Source: docs/architecture/2-appwrite-database-schema.md]:**

- Collection ID: `races`
- Status field: `status` (String, required) - race status enum value
- Valid status values: `'Open'`, `'Closed'`, `'Running'`, `'Finalized'`
- Status determines visual styling and user interaction capabilities
- Status updates trigger real-time events via Appwrite subscriptions

**Status Business Logic:**

- **Open**: Betting is available, race hasn't started
- **Closed**: Betting closed, race about to start
- **Running**: Race is currently in progress
- **Finalized**: Race completed, results available

**Race Status Colors [Source: client/src/services/races.ts]:**

- Already implemented `getRaceStatusColor()` function:
  - Open: `text-green-600`
  - Closed: `text-yellow-600`
  - Running: `text-blue-600`
  - Finalized: `text-gray-600`

### API Specifications

**Appwrite Real-time Subscriptions [Source: client/src/hooks/useRealtimeMeetings.tsx]:**

**Subscription Channels Already Established:**

```javascript
// Already subscribed in useRealtimeMeetings hook
const unsubscribe = client.subscribe([
  'databases.raceday-db.collections.meetings.documents',
  'databases.raceday-db.collections.races.documents' // ✅ Status updates via this channel
], async (response) => {
  // Race status updates handled in existing subscription
});
```

**Real-time Event Handling [Source: client/src/hooks/useRealtimeMeetings.tsx]:**

```javascript
// Current race update handling in useRealtimeMeetings
if (events.some(e => e.includes('races.documents'))) {
  const race = payload as Race;
  
  // Update race cache for expanded meetings
  if (events.some(e => e.includes('.update'))) {
    updateRaceInCache(race.meeting, race); // ✅ Already updates race status
  }
}
```

**High-Frequency Polling Trigger [Source: server/single-race-poller/src/main.js]:**

- Next.js Server Action to trigger `single-race-poller` function
- Function accepts `{ raceId: "race-uuid" }` payload
- Returns immediate response, processes updates in background
- Database updates trigger real-time subscriptions to client

**Performance Requirements [Source: docs/architecture/4-frontend-real-time-communication.md]:**

- Real-time latency: <2 seconds for status updates (matches AC #1)
- Update batching during high-frequency status changes
- Efficient re-rendering with React.memo optimization
- Connection retry logic with exponential backoff (already implemented)

### Component Specifications

**Project Structure [Source: docs/architecture/7-source-tree.md]:**

```
client/src/
├── components/
│   ├── dashboard/
│   │   ├── RaceCard.tsx             # MODIFY: Enhance status visual styling
│   │   ├── RacesList.tsx            # EXISTING: Container handles status updates
│   │   └── MeetingsListClient.tsx   # EXISTING: Main meetings container
├── hooks/
│   ├── useRealtimeMeetings.tsx      # EXISTING: Already handles race status updates optimally
│   └── useRacesForMeeting.tsx       # EXISTING: Race fetching with caching
├── services/
│   └ races.ts                     # EXISTING: Race data service with validation
├── styles/
│   └── globals.css                  # MODIFY: Add comprehensive status styling classes
└── app/
    └── actions/
        └── poll-race.ts             # NEW: Server Action to trigger single-race-poller
```

**Component Enhancement Requirements:**

- **RaceCard.tsx** (MODIFY): Enhance visual status indicators with clear color coding and accessibility
- **globals.css** (MODIFY): Add comprehensive status indicator classes with accessibility compliance
- **poll-race.ts** (NEW): Server Action for triggering high-frequency race polling

### File Locations

**Files to Modify [Source: docs/architecture/7-source-tree.md + Next.js 15 Architecture]:**

- `client/src/components/dashboard/RaceCard.tsx` - Enhanced status visual indicators and accessibility
- `client/src/services/races.ts` - Already has status colors, may need enhanced styling classes
- `client/src/styles/globals.css` - Add comprehensive status indicator styling classes

**Files to Create:**

- `client/src/app/actions/poll-race.ts` - Server Action to trigger single-race-poller function

**No Changes Required:**

- `client/src/hooks/useRealtimeMeetings.tsx` - Already handles race status updates optimally
- Real-time subscription infrastructure already established in Story 3.2
- Service layer already handles status validation and colors

### Next.js 15 Performance Requirements

**Server Component vs Client Component Usage [Source: docs/architecture/4-frontend-real-time-communication.md]:**

- **Server Components**: No changes needed (initial data fetching already optimized)
- **Client Components**: Status updates are real-time interactive, perfect for existing Client Component architecture
- **Hybrid Pattern**: Existing Server/Client hybrid pattern maintains optimal performance

**Appwrite Dual SDK Strategy [Source: docs/architecture/6-tech-stack.md]:**

- **Server SDK** (`node-appwrite`): No additional server-side changes needed
- **Client SDK** (`appwrite`): Already configured for real-time race subscriptions
- **Security**: Existing API key server-side only pattern maintained

**Bundle Optimization and Lazy Loading [Source: docs/architecture/6-tech-stack.md]:**

```typescript
// No additional bundle impact - status styling uses existing CSS
// Real-time updates use existing subscription infrastructure
// Component optimizations already implemented with React.memo()

// Status styling with Tailwind CSS (zero bundle impact)
const statusClasses = {
  Open: 'bg-green-100 text-green-800 border-green-200',
  Closed: 'bg-yellow-100 text-yellow-800 border-yellow-200', 
  Running: 'bg-blue-100 text-blue-800 border-blue-200',
  Finalized: 'bg-gray-100 text-gray-800 border-gray-200'
};
```

**Performance Targets:**

- Real-time status updates: <2s latency (AC requirement)
- No additional bundle size increase (use existing infrastructure)
- React.memo() optimization maintains efficient re-rendering
- Status visual updates render <100ms after data update

### Appwrite Best Practices

**SDK Configuration Patterns [Source: docs/architecture/4-frontend-real-time-communication.md]:**

- **Existing Configuration**: Client SDK already properly configured for real-time subscriptions
- **No Changes Required**: Status updates use existing real-time infrastructure
- **Optimization**: Maintain selective subscription pattern to races collection only

**Database Query Optimization [Source: docs/architecture/4-frontend-real-time-communication.md]:**

- **Existing Queries**: Race data already efficiently fetched and cached
- **Real-time Updates**: Status updates flow through existing subscription channels
- **No Additional Queries**: Status changes received via real-time events, not polling

**Real-time Subscription Management [Source: docs/architecture/4-frontend-real-time-communication.md]:**

```typescript
// Existing optimized subscription pattern
const channels = [
  'databases.raceday-db.collections.races.documents' // Status updates via this channel
];

// Optimized update handling for status changes
const handleRaceUpdate = useCallback((response) => {
  if (response.events.includes('databases.raceday-db.collections.races.documents.*.update')) {
    // Batch status updates during high-frequency periods
    updateRaceStatus(response.payload);
  }
}, []);
```

**Error Handling and Retry Logic [Source: docs/architecture/4-frontend-real-time-communication.md]:**

- **Connection Management**: Existing retry logic with exponential backoff
- **Graceful Degradation**: Status displays cached values during connection issues
- **User Feedback**: Connection status indicators already implemented

**Security and Authentication Patterns [Source: docs/architecture/4-frontend-real-time-communication.md]:**

- **Session Management**: Existing authentication patterns maintained
- **No Additional Security**: Status updates use existing secure subscription channels
- **Client Permissions**: Race status updates visible to all authenticated users

### Testing Requirements

**Testing Strategy [Source: docs/architecture/8-coding-standards.md]:**

**Component Testing:**

- Test RaceCard status visual indicators for all status values
- Test status color coding and accessibility compliance
- Test status updates via real-time events
- Test status display during connection issues

**Real-time Testing:**

- Mock Appwrite subscription events for status changes
- Test status update batching during high-frequency changes
- Test connection retry behavior with status updates
- Test performance during rapid status changes

**Integration Testing:**

- Test end-to-end status updates from subscription to UI
- Test status updates preserve expand/collapse state
- Test status updates during meeting list updates
- Test multiple races status updates simultaneously

**Specific Test Cases:**

- Status changes from Open → Closed → Running → Finalized in sequence
- Visual indicators correctly reflect status changes in real-time
- Accessibility features work with dynamic status updates
- Performance remains stable during high-frequency status updates
- Error handling when status update fails or is invalid

### Technical Constraints

**Frontend Standards [Source: docs/architecture/8-coding-standards.md]:**

- **TypeScript exclusively** for all status-related type definitions
- **Next.js App Router** patterns maintained (no changes needed)
- **Tailwind CSS** for status styling with consistent design system
- **React.memo()** optimization maintained for all components
- **Existing Component Architecture**: Build on established RaceCard/RacesList pattern

**Real-time Requirements [Source: docs/architecture/4-frontend-real-time-communication.md]:**

- Maintain <2s latency for status updates (AC requirement)
- Efficient re-rendering when status changes
- Handle connection errors gracefully with cached status display
- Preserve UI state during status updates

**Performance Constraints:**

- No additional bundle size impact (use existing infrastructure)
- Maintain existing caching strategies
- React.memo() optimization prevents unnecessary re-renders
- Status styling uses efficient Tailwind CSS classes

### UI/UX Requirements

**Status Visual Design:**

- **Open**: Green indicator - betting available, clear call-to-action styling
- **Closed**: Yellow/Orange indicator - betting closed, race imminent
- **Running**: Blue indicator - race in progress, animated or pulsing effect
- **Finalized**: Gray indicator - race complete, subdued styling

**Visual Implementation:**

- Status badge/chip display with consistent sizing
- Color coding with sufficient contrast ratios (WCAG 2.1 AA compliance)
- Status text labels for screen readers
- Consistent placement within RaceCard component
- Smooth transitions between status changes

**Accessibility Requirements:**

- ARIA live regions announce status changes to screen readers
- Color coding supplemented with text/icons for color-blind users
- Sufficient color contrast ratios for all status indicators
- Status changes announced with appropriate urgency levels
- Keyboard navigation maintains focus during status updates

**Responsive Design:**

- Status indicators remain legible at mobile and desktop sizes
- Consistent spacing and typography across device sizes
- Touch-friendly status elements on mobile devices
- Status updates don't cause layout shifts

**Performance UX:**

- Status updates appear <100ms after data change
- Smooth animations for status transitions (max 200ms duration)
- Loading states if status update is delayed
- Optimistic updates where appropriate

## Tasks / Subtasks

### Task 1: Enhance Race Status Visual Indicators (AC: 2)

- [ ] 1.1. Update `client/src/components/dashboard/RaceCard.tsx` to enhance status display styling
- [ ] 1.2. Implement comprehensive status badges using existing color system from races service
- [ ] 1.3. Add status transition animations for smooth visual updates
- [ ] 1.4. Implement accessibility features (ARIA live regions, color contrast, status announcements)
- [ ] 1.5. Add status-specific icons or visual elements for better recognition and color-blind accessibility

### Task 2: Create Server Action for High-Frequency Race Polling (AC: 1, 3)

- [ ] 2.1. Create `client/src/app/actions/poll-race.ts` Server Action to trigger single-race-poller
- [ ] 2.2. Use Appwrite node.js SDK for secure function execution
- [ ] 2.3. Implement proper error handling and timeout management
- [ ] 2.4. Add logic to determine when high-frequency polling is needed (race approaching start)
- [ ] 2.5. Return appropriate response indicating polling status and expected latency

### Task 3: Enhance Status Display System (AC: 2, 3)

- [ ] 3.1. Add comprehensive status indicator classes to `client/src/styles/globals.css`
- [ ] 3.2. Implement accessibility-compliant color palette with sufficient contrast ratios
- [ ] 3.3. Create responsive status indicators for mobile and desktop
- [ ] 3.4. Add status transition animations with performance optimization
- [ ] 3.5. Implement status validation and error handling for invalid status values

### Task 4: Integrate High-Frequency Polling with Race Lifecycle (AC: 1)

- [ ] 4.1. Add logic to trigger high-frequency polling for races approaching start time
- [ ] 4.2. Implement polling trigger based on race timing (T-10m to T+60m window)
- [ ] 4.3. Use existing real-time subscription infrastructure to handle status updates
- [ ] 4.4. Add performance monitoring to ensure <2s latency requirement
- [ ] 4.5. Implement graceful degradation when polling or subscriptions fail

### Task 5: Comprehensive Status Testing Implementation (Testing Requirements)

- [ ] 5.1. Create unit tests for RaceCard status display with all status values
- [ ] 5.2. Test status visual indicators and accessibility compliance
- [ ] 5.3. Test Server Action for triggering single-race-poller function
- [ ] 5.4. Test real-time status updates via mocked subscription events
- [ ] 5.5. Integration tests for end-to-end status update flow
- [ ] 5.6. Performance tests for status update latency and high-frequency scenarios
- [ ] 5.7. Accessibility tests for status indicators and screen reader support

## Testing

**Testing Requirements [Source: docs/architecture/8-coding-standards.md + Next.js 15 Testing]:**

- Test files located alongside components with `.test.tsx` extension
- Use Jest and React Testing Library for component testing
- Mock Appwrite SDK real-time events for status updates
- Test status visual indicators and accessibility compliance
- Test real-time status update performance and latency
- Performance testing for status update impact on rendering
- Integration testing for end-to-end status update workflow

**Specific Test Cases:**

- RaceCard renders correct status indicators for all four status values
- Status color coding meets accessibility contrast requirements
- Real-time status updates trigger appropriate visual changes
- Status update latency meets <2s requirement from acceptance criteria
- Status updates preserve expand/collapse state in meetings
- Connection errors gracefully display cached status values
- Screen readers announce status changes with appropriate urgency

## Change Log

| Date       | Version | Description                                                                 | Author             |
| ---------- | ------- | --------------------------------------------------------------------------- | ------------------ |
| 2025-08-05 | 1.0     | Initial story creation with comprehensive technical context and requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

- [To be filled by Dev Agent]

### Debug Log References

- [To be filled by Dev Agent]

### Completion Notes

- [To be filled by Dev Agent]

### File List

- [To be filled by Dev Agent]

## QA Results

- [To be filled by QA Agent]