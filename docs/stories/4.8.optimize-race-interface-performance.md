# Story 4.8: Optimize Race Interface Performance Architecture

**Status**: Draft

**As a** user navigating between races and viewing real-time data updates  
**I want** rapid page transitions (<200ms), instant navigation between races (<100ms), immediate race interface rendering when clicking on races from meetings, and smooth real-time updates  
**So that** I can quickly analyze multiple races without waiting for slow page loads or experiencing laggy skeleton screens.

## Acceptance Criteria

1. Initial race page load achieves <200ms first paint with progressive client-side rendering instead of heavy server-side data loading
2. Navigation between races completes in <100ms using client-side routing with pre-cached data instead of full page refreshes
3. Transition from meetings component to race page immediately renders race interface structure (header, navigation, basic grid) within <100ms instead of showing skeleton loading screen
4. Real-time data updates display within <50ms of WebSocket events with optimized subscription architecture
5. Client-side data architecture utilizes existing cache system for instant navigation and reduces memory usage by 60%
6. Consolidated real-time hooks replace the current 3-hook architecture (useRealtimeRace, useRealtimeEntrants, useEnhancedRealtime) with single optimized hook
7. Progressive data loading strategy loads basic race data first (50ms), then entrants (100ms), navigation (150ms), and historical data in background

## Story Context

This story implements the **critical performance optimization requirements** identified in the architectural review by Winston (Architect). The current Next.js application has severe performance bottlenecks that compromise the two key user experience objectives:

1. **Fast, rapid screen updating when navigating between races**
2. **Live subscribed data updating**

**Key Performance Issues Addressed:**
- **Heavy Server-Side Rendering**: 700+ database records loaded server-side before showing any content (3-5 second blocking)
- **Inefficient Navigation**: Client-side navigation still loads comprehensive data instead of using progressive loading
- **Slow Meeting-to-Race Transitions**: Clicking on races from meetings shows skeleton loading screens instead of immediate race interface rendering
- **Over-engineered Real-time**: 3 separate hooks with complex batching causing delays and connection instability  
- **Unused Optimizations**: Existing cache system and fast navigation APIs not utilized in critical rendering paths

**Expected Performance Improvements:**
- **Initial page load**: 3-5 seconds → 200-500ms (10x faster)
- **Navigation speed**: 1-3 seconds → 50-100ms (20x faster) 
- **Meeting-to-race transitions**: Skeleton loading → Instant race interface rendering (immediate UI feedback)
- **Real-time update latency**: 100-500ms → 10-50ms (5x faster)
- **Memory usage**: 60% reduction through optimized state management

## Dev Notes

### Next.js 15 Performance Requirements

**Server Component vs Client Component Strategy:** [Source: docs/architecture/3-frontend-architecture-nextjs-15.md#L66-L87]

**Current Problem - Heavy SSR Blocking:**
```typescript
// CURRENT: Heavy server-side data loading blocks rendering 3-5 seconds
async function getComprehensiveRaceData(raceId: string) {
  // Loads 500+ odds history records
  // Loads 200+ money flow records  
  // Blocks page render until ALL data loaded
}
```

**Required Solution - Progressive Client-Side:**
```typescript
// NEW: Lightweight server component + progressive client loading
export default function RaceDetailPage({ params }: RaceDetailPageProps) {
  return (
    <Suspense fallback={<RaceDetailSkeleton />}>
      <ClientRaceView raceId={params.id} />
    </Suspense>
  );
}

// Progressive loading: basic data → entrants → navigation → historical
function useProgressiveRaceData(raceId: string) {
  // Load data in priority order with performance targets:
  // 1. Race basic info (50ms)
  // 2. Entrants basic data (100ms)
  // 3. Navigation data (150ms)
  // 4. Historical data (background)
}
```

**Bundle Optimization Requirements:** [Source: docs/architecture/8-coding-standards.md#L97-L105]
- React.memo() for all enhanced components 
- useMemo() for heavy calculations (money flow processing, column generation)
- useCallback() for event handlers and sorting functions
- Dynamic imports for heavy visualization components

### Appwrite Best Practices

**Dual SDK Strategy:** [Source: docs/architecture/8-coding-standards.md#L150-L180]

**Server-Side (node-appwrite):**
```typescript
// lib/appwrite-server.ts - Only for initial data fetching
import { Client, Databases } from 'node-appwrite';

export async function createServerClient() {
  const client = new Client()
    .setEndpoint(process.env.NEXT_PUBLIC_APPWRITE_ENDPOINT!)
    .setProject(process.env.NEXT_PUBLIC_APPWRITE_PROJECT_ID!)
    .setKey(process.env.APPWRITE_API_KEY!); // Server-only API key

  return { get databases() { return new Databases(client); } };
}
```

**Client-Side (appwrite web SDK):**
```typescript  
// lib/appwrite-client.ts - For real-time and navigation
'use client';
import { Client, Databases } from 'appwrite';

const client = new Client()
  .setEndpoint(process.env.NEXT_PUBLIC_APPWRITE_ENDPOINT!)
  .setProject(process.env.NEXT_PUBLIC_APPWRITE_PROJECT_ID!);
  // No API key - uses session authentication

export const databases = new Databases(client);
export { client };
```

**Query Optimization Requirements:** [Source: docs/architecture/4-database-schema-appwrite.md#L24-L31]
- Use compound indexes for time-series queries (entrant + pollingTimestamp)
- Implement Query.limit() for initial loads, paginate historical data
- Batch query optimization with Query.equal() for multiple entrants
- Use Query.greaterThan() / Query.lessThan() for time-based filtering

### Cache Integration Strategy

**Existing Cache System Integration:** [Source: client/src/lib/cache.ts]

**Current Problem:**
```typescript
// Navigation ignores existing sophisticated cache system
const response = await fetch(`/api/race/${raceId}?nav=true`);
```

**Required Implementation:**
```typescript
import { raceCache, entrantsCache, navigationCache } from '@/lib/cache';

const navigateToRace = useCallback(async (raceId: string) => {
  try {
    // Use existing cache system for instant navigation
    const raceData = await raceCache.get(
      `race:${raceId}`,
      () => fetch(`/api/race/${raceId}?nav=true`).then(r => r.json()),
      15000 // 15 second cache for live data
    );
    
    setRaceData(raceData);
    window.history.pushState({}, '', `/race/${raceId}`);
  } finally {
    setIsLoading(false);
  }
}, []);
```

**Cache Configuration:** [Source: client/src/lib/cache.ts#L188-L194]
- Race data: 15-30 second TTL for live data freshness  
- Entrants: 60 second TTL for less volatile basic data
- Navigation: 5 minute TTL for race relationships
- Memory management with LRU eviction (1000 item limit)

### Real-time Subscription Optimization

**Current Problem - 3 Separate Hooks:** [Source: client/src/hooks/]
```typescript
// Multiple hooks causing complexity and performance issues:
useRealtimeRace({ initialRace });          // Hook 1
useRealtimeEntrants({ initialEntrants });  // Hook 2  
useEnhancedRealtime({ initialData });      // Hook 3
// Each with separate WebSocket connections, batching, cleanup
```

**Required Consolidation:** 
```typescript
// NEW: Single optimized hook replacing all three
function useRaceRealtime({ raceId }: { raceId: string }) {
  // Single subscription channel with smart filtering
  // Unified state management for race + entrants + money flow
  // Optimized batching (10ms instead of 50ms)
  // Intelligent reconnection logic
  // Reduced memory usage through single connection
}
```

**Subscription Architecture Optimization:** [Source: docs/architecture/3-frontend-architecture-nextjs-15.md#L90-L100]
```typescript
// Instead of 3 separate subscriptions:
// - databases.raceday-db.collections.races.documents.${raceId}
// - databases.raceday-db.collections.entrants.documents  
// - databases.raceday-db.collections.money-flow-history.documents

// Use single subscription with server-side filtering:
client.subscribe(`databases.raceday-db.race-updates.${raceId}`, (response) => {
  // Server filters and batches all race-related updates
  // Client receives optimized update payload
});
```

### Meeting-to-Race Transition Optimization

**Current Problem - Skeleton Loading Delay:** [Source: client/src/app/race/[id]/page.tsx:58]

```typescript
// CURRENT: Shows skeleton while loading comprehensive data
export default function RaceDetailPage({ params }: RaceDetailPageProps) {
  return (
    <Suspense fallback={<RaceDetailSkeleton />}>
      <ClientRaceView raceId={params.id} />
    </Suspense>
  );
}

// User clicks race → skeleton shows → 3-5 seconds → race interface appears
```

**Required Solution - Immediate Race Interface Rendering:**

```typescript
// NEW: Immediate race interface rendering with progressive enhancement
export default function RaceDetailPage({ params }: RaceDetailPageProps) {
  return (
    <RaceProvider initialData={null}>
      <RacePageContent 
        raceId={params.id}
        renderMode="immediate" // Skip skeleton, render structure immediately
      />
    </RaceProvider>
  );
}

// User clicks race → race interface structure appears immediately → data progressively loads
```

**Meeting Component Integration:** [Source: client/src/components/dashboard/RaceCard.tsx:55-58]

**Current onClick Handler:**
```typescript
// RaceCard onClick calls this handler
const handleClick = () => {
  if (onClick) {
    onClick(race.raceId); // Navigates to race page via router.push()
  }
};
```

**Required Enhancement:**
```typescript
// Enhanced onClick with race data pre-fetching
const handleClick = async () => {
  if (onClick) {
    // Pre-fetch basic race data before navigation to avoid skeleton
    const basicRaceData = await prefetchBasicRaceData(race.raceId);
    
    // Navigate with cached data for immediate rendering
    onClick(race.raceId, { prefetchedData: basicRaceData });
  }
};
```

**Pre-caching Strategy for Meetings:**
- When MeetingCard expands and shows RacesList, immediately pre-cache basic data for all visible races
- Use background fetch with 30-second cache to prepare for user clicks
- Store in existing cache system (raceCache) for instant retrieval

### File Locations and Implementation Structure

**Critical Files to Modify:** [Source: docs/architecture/7-source-tree.md#L22-L27]

1. **Primary Race Page**: `/client/src/app/race/[id]/page.tsx`
   - Convert from heavy SSR to lightweight server component  
   - Remove getComprehensiveRaceData() server-side loading
   - Implement Suspense + ClientRaceView pattern

2. **New Progressive Hook**: `/client/src/hooks/useProgressiveRaceData.ts` (NEW FILE)
   - Replace existing data loading with staged approach
   - Implement performance targets (50ms basic, 100ms entrants, etc.)

3. **Consolidated Real-time**: `/client/src/hooks/useRaceRealtime.ts` (NEW FILE)  
   - Replace useRealtimeRace, useRealtimeEntrants, useEnhancedRealtime
   - Single subscription channel with unified state

4. **Race Context Enhancement**: `/client/src/contexts/RaceContext.tsx`
   - Integrate cache system in navigateToRace()
   - Implement client-side state management optimization
   - Add pre-caching for adjacent races

5. **API Route Optimization**: `/client/src/app/api/race/[id]/route.ts`
   - Enhance fast navigation mode (getNavigationRaceData)
   - Implement progressive data endpoints
   - Cache-friendly response headers

6. **Meeting Components Enhancement**: 
   - `/client/src/components/dashboard/RaceCard.tsx`: Add pre-fetching onClick handler
   - `/client/src/components/dashboard/RacesList.tsx`: Background pre-caching when races are displayed
   - `/client/src/components/dashboard/MeetingCard.tsx`: Trigger pre-caching on expand

**Component Structure Enhancements:**
- **RacePageContent.tsx**: Support null initialData + immediate rendering mode for progressive loading
- **NavigationHeader.tsx**: Pre-cache adjacent race data
- **EnhancedEntrantsGrid.tsx**: Graceful loading states during data progression with immediate structure rendering

### Testing Requirements

**Performance Testing Strategy:** [Source: docs/architecture/8-coding-standards.md#L206-L224]

**Component Testing:**
- Progressive loading hook with staged data loading
- Cache integration with hit/miss scenarios  
- Real-time subscription consolidation and reconnection
- Client-side navigation speed and state preservation

**Performance Testing:**
```typescript
// Test performance targets
describe('Performance Optimization', () => {
  it('initial race page load under 200ms', async () => {
    const startTime = performance.now();
    render(<RaceDetailPage params={{ id: 'test-race' }} />);
    const loadTime = performance.now() - startTime;
    expect(loadTime).toBeLessThan(200);
  });

  it('navigation between races under 100ms', async () => {
    // Test client-side navigation performance
  });

  it('real-time updates under 50ms latency', async () => {
    // Test WebSocket update to UI render latency
  });
});
```

**Integration Testing:**
- End-to-end navigation flow with cache utilization
- Real-time subscription behavior during progressive loading
- Memory usage validation (60% reduction target)
- Cross-race navigation with state preservation

## Acceptance Criteria to Task Mapping

| Acceptance Criteria | Primary Tasks | Supporting Tasks |
|---------------------|---------------|------------------|
| AC1: Initial race page load <200ms | T1 (SSR→Client conversion) | T2 (Progressive loading), T7 (Component updates) |
| AC2: Navigation <100ms | T3 (Cache integration) | T8 (Performance monitoring) |
| AC3: Meeting-to-race transitions <100ms | T6 (Meeting transitions) | T3 (Cache integration) |
| AC4: Real-time updates <50ms | T4 (Real-time consolidation) | T8 (Performance monitoring) |
| AC5: Memory reduction 60% | T9 (Bundle optimization) | T4 (Hook consolidation) |
| AC6: Consolidated hooks | T4 (Real-time consolidation) | T9 (Memory management) |
| AC7: Progressive loading strategy | T2 (Progressive data loading) | T5 (API optimization), T7 (Component support) |

## Tasks / Subtasks

- [ ] T1: Convert race page to progressive client-side rendering (AC: 1)
  - [ ] ST1.1: Modify `/client/src/app/race/[id]/page.tsx` to lightweight server component with Suspense
  - [ ] ST1.2: Create `/client/src/components/ClientRaceView.tsx` for progressive client loading
  - [ ] ST1.3: Remove heavy `getComprehensiveRaceData()` server-side blocking function
  - [ ] ST1.4: Implement `RaceDetailSkeleton` component for instant first paint
  - [ ] ST1.5: Test first paint performance target <200ms with Lighthouse

- [ ] T2: Implement progressive data loading strategy (AC: 1,7)
  - [ ] ST2.1: Create `/client/src/hooks/useProgressiveRaceData.ts` with staged loading approach
  - [ ] ST2.2: Implement basic race data loading (target: 50ms)
  - [ ] ST2.3: Implement entrants data loading (target: 100ms after basic)
  - [ ] ST2.4: Implement navigation data loading (target: 150ms after basic)
  - [ ] ST2.5: Implement background historical data loading (non-blocking)
  - [ ] ST2.6: Add error handling and fallback strategies for each loading stage

- [ ] T3: Integrate existing cache system for navigation (AC: 2,3)
  - [ ] ST3.1: Modify `/client/src/contexts/RaceContext.tsx` navigateToRace() to use raceCache
  - [ ] ST3.2: Implement cache-first navigation strategy with 15-second TTL for live data
  - [ ] ST3.3: Add pre-caching for adjacent races in NavigationHeader component
  - [ ] ST3.4: Implement cache invalidation strategies for real-time updates
  - [ ] ST3.5: Test navigation performance target <100ms with cached data
  - [ ] ST3.6: Add cache metrics monitoring for hit/miss rates

- [ ] T4: Consolidate real-time subscription architecture (AC: 4,6)
  - [ ] ST4.1: Create `/client/src/hooks/useRaceRealtime.ts` to replace 3 existing hooks
  - [ ] ST4.2: Implement single subscription channel with unified state management
  - [ ] ST4.3: Optimize batching mechanism to 10ms (from current 50ms)
  - [ ] ST4.4: Remove complex cleanup and retry logic from individual hooks
  - [ ] ST4.5: Implement intelligent reconnection with exponential backoff
  - [ ] ST4.6: Test real-time update latency target <50ms from WebSocket to UI

- [ ] T5: Optimize API routes for progressive loading (AC: 7)
  - [ ] ST5.1: Enhance `/client/src/app/api/race/[id]/route.ts` getNavigationRaceData() function
  - [ ] ST5.2: Create separate endpoints for staged data loading (/api/race/[id]/basic, /entrants, /navigation)
  - [ ] ST5.3: Implement cache-friendly response headers for different data types
  - [ ] ST5.4: Add query parameter support for progressive loading modes
  - [ ] ST5.5: Optimize database queries with proper indexing for staged loading
  - [ ] ST5.6: Test API response times meet progressive loading targets

- [ ] T6: Optimize meeting-to-race transitions for immediate rendering (AC: 3)
  - [ ] ST6.1: Modify `RacePageContent.tsx` to support immediate rendering mode that skips skeleton loading
  - [ ] ST6.2: Enhance `/client/src/components/dashboard/RaceCard.tsx` onClick handler to pre-fetch basic race data before navigation
  - [ ] ST6.3: Implement background pre-caching in `RacesList.tsx` when races are displayed in expanded MeetingCard
  - [ ] ST6.4: Add pre-caching trigger in `MeetingCard.tsx` when user expands to see races
  - [ ] ST6.5: Create `/client/src/services/racePrefetchService.ts` for basic race data pre-fetching with cache integration
  - [ ] ST6.6: Test meeting-to-race transition performance target <100ms for race interface structure rendering

- [ ] T7: Update components for progressive loading support (AC: 1,7)
  - [ ] ST7.1: Modify `RacePageContent.tsx` to handle null initialData gracefully  
  - [ ] ST7.2: Add loading states and skeletons for progressive data arrival
  - [ ] ST7.3: Update `EnhancedEntrantsGrid.tsx` to render basic data first, enhance progressively
  - [ ] ST7.4: Implement smooth transitions between loading states
  - [ ] ST7.5: Add error boundaries for failed progressive loading stages
  - [ ] ST7.6: Ensure accessibility during progressive loading with proper ARIA announcements

- [ ] T8: Implement performance monitoring and validation (AC: 1,2,3,4)
  - [ ] ST8.1: Add performance metrics collection for page load, navigation, meeting-to-race transitions, and real-time updates
  - [ ] ST8.2: Implement Lighthouse performance testing in CI/CD pipeline
  - [ ] ST8.3: Add memory usage monitoring and 60% reduction validation
  - [ ] ST8.4: Create performance dashboard for monitoring optimization effectiveness
  - [ ] ST8.5: Implement alerting for performance regression detection
  - [ ] ST8.6: Add user experience metrics (CLS, FCP, LCP) monitoring

- [ ] T9: Bundle optimization and memory management (AC: 5,6)
  - [ ] ST9.1: Implement React.memo() wrapping for all race view components
  - [ ] ST9.2: Add useMemo() for expensive calculations (money flow processing, column generation)
  - [ ] ST9.3: Add useCallback() for event handlers and sorting functions  
  - [ ] ST9.4: Implement dynamic imports with next/dynamic for heavy components
  - [ ] ST9.5: Optimize bundle splitting for race view modules
  - [ ] ST9.6: Test and validate 60% memory usage reduction target

- [ ] T10: Integration testing and performance validation (AC: 1,2,3,4,5,6,7)
  - [ ] ST10.1: Create end-to-end tests for progressive loading with performance assertions
  - [ ] ST10.2: Test navigation performance with cache hit/miss scenarios
  - [ ] ST10.3: Test meeting-to-race transition performance with immediate rendering validation
  - [ ] ST10.4: Test real-time subscription behavior during progressive loading
  - [ ] ST10.5: Validate memory usage and connection stability improvements
  - [ ] ST10.6: Test cross-browser compatibility for optimization features
  - [ ] ST10.7: Load test with concurrent users to validate performance improvements at scale

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-14 | 1.0 | Initial draft created from Winston's architectural performance optimization brief. Addresses critical SSR bottlenecks, inefficient navigation, over-engineered real-time architecture, and unused performance optimizations. Targets 10-20x performance improvements through progressive client-side rendering, cache integration, and consolidated real-time subscriptions. | Bob (Scrum Master) |
| 2025-01-14 | 1.1 | Enhanced with meeting-to-race transition optimization requirement. Added AC3 for immediate race interface rendering when clicking races from meetings, eliminating skeleton loading screens. Includes pre-caching strategy for visible races and enhanced onClick handlers in meeting components. Added T6 task for meeting-to-race optimization with 6 subtasks covering RaceCard enhancement, RacesList pre-caching, and racePrefetchService creation. | Bob (Scrum Master) |
| 2025-01-14 | 1.2 | Template compliance and source verification fix: (1) Added missing Dev Agent Record and QA Results sections required by story template, (2) Verified and corrected source references - all architecture file references validated as accurate, updated cache.ts line reference from L80-90 to L188-194, (3) Added AC-to-Task mapping table for clear traceability, (4) Corrected all task AC references to match mapping table. Story now meets all template requirements and source references are verified accurate. | Bob (Scrum Master) |