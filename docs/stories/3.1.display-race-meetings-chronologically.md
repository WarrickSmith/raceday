# Story 3.1: Display race meetings chronologically

**Status**: Draft

**As a** user  
**I want** to see a list of all race meetings for the current day, ordered chronologically by the first race of the meeting  
**So that** I can easily scan upcoming races.

## Acceptance Criteria

1. Meetings are displayed in chronological order.
2. The list updates in real-time as new meetings are added or removed.
3. No duplicate meetings are shown.

## Dev Notes

### Previous Story Insights

**Frontend Foundation [Source: Story 1.1]:**
- Next.js 15+ with TypeScript already initialized in `client/` directory
- `/src` directory structure established with App Router
- Development server working with `npm run dev`

**Backend Infrastructure [Source: Story 2.1, 2.2]:**
- Appwrite database schema established with collections
- Database ID: `raceday-db`
- Real-time data polling functions implemented and working
- Daily race import populating meetings and races data

**Appwrite Configuration [Source: Story 1.3]:**
- Appwrite client configuration using environment variables
- Environment variables: `NEXT_PUBLIC_APPWRITE_ENDPOINT`, `NEXT_PUBLIC_APPWRITE_PROJECT_ID`, `APPWRITE_API_KEY`
- Appwrite setup script created for database and collections

### Data Models

**Meetings Collection Schema [Source: docs/architecture/2-appwrite-database-schema.md]:**
- Collection ID: `meetings`
- Fields required for chronological display:
  - `meetingId` (String, required) - primary identifier
  - `meetingName` (String, required) - display name
  - `country` (String, required) - AU/NZ filtering
  - `raceType` (String, required) - Horse/Harness racing types
  - `date` (DateTime, required) - meeting date for filtering current day
  - Relationship to `races` collection for ordering by first race

**Races Collection Schema [Source: docs/architecture/2-appwrite-database-schema.md]:**
- Collection ID: `races`
- Fields required for chronological ordering:
  - `raceId` (String, required) - primary identifier
  - `raceNumber` (Integer, required) - race sequence in meeting
  - `raceName` (String, required) - display name
  - `startTime` (DateTime, required) - for chronological ordering
  - `meeting` (Relationship to Meetings) - linking back to meeting
  - `status` (String, required) - race status for filtering

### API Specifications

**Appwrite Database Queries [Source: docs/architecture/4-frontend-real-time-communication.md]:**

**Query for Today's Meetings with First Race Time:**
```javascript
// Query meetings for current day with races relationship
await databases.listDocuments('raceday-db', 'meetings', [
  Query.equal('date', today),
  Query.equal('country', ['AU', 'NZ']),
  Query.equal('raceType', ['Thoroughbred Horse Racing', 'Harness']),
  Query.orderAsc('$id') // Will be sorted by first race time in component
]);

// Query races for each meeting to find earliest start time
await databases.listDocuments('raceday-db', 'races', [
  Query.equal('meeting', meetingId),
  Query.orderAsc('startTime'),
  Query.limit(1) // Only need first race for ordering
]);
```

**Real-time Subscriptions [Source: docs/architecture/4-frontend-real-time-communication.md]:**
- Subscribe to `databases.raceday-db.collections.meetings.documents` for meeting updates
- Subscribe to `databases.raceday-db.collections.races.documents` for race time changes
- Data updates propagate to UI <2s latency requirement

### Component Specifications

**Project Structure [Source: docs/architecture/7-source-tree.md]:**
```
client/src/
├── app/
│   ├── (main)/
│   │   ├── page.tsx         # Main dashboard - implements meetings list
│   │   └── layout.tsx       # Main layout wrapper
├── components/
│   ├── dashboard/           # Dashboard-specific components
│   │   ├── MeetingsList.tsx # NEW: Main meetings list component
│   │   └── MeetingCard.tsx  # NEW: Individual meeting display
│   ├── common/              # Reusable UI components
│   └── layout/              # Layout components
├── lib/
│   ├── appwrite.ts          # Appwrite client configuration
│   └── utils.ts             # Utility functions
├── hooks/                   # Custom React hooks
│   └── useMeetings.tsx      # NEW: Meetings data hook with real-time
└── services/                # Backend service interactions
    └── meetings.ts          # NEW: Meetings API service layer
```

**Component Requirements:**
- **MeetingsList.tsx**: Main container displaying chronologically ordered meetings
- **MeetingCard.tsx**: Individual meeting display showing name, country, race type, first race time
- **useMeetings.tsx**: React hook managing real-time meeting data with Appwrite subscriptions
- **meetings.ts**: Service layer for meeting queries and real-time subscriptions

### File Locations

**New Files to Create [Source: docs/architecture/7-source-tree.md + Next.js 15 Architecture]:**
- `client/src/lib/appwrite-server.ts` - Server-side Appwrite configuration (node-appwrite)
- `client/src/lib/appwrite-client.ts` - Client-side Appwrite configuration (appwrite web SDK)
- `client/src/server/meetings-data.ts` - Server Component data fetching functions
- `client/src/components/dashboard/MeetingsListClient.tsx` - Client Component for real-time updates
- `client/src/components/dashboard/MeetingCard.tsx` - Optimized meeting card component
- `client/src/components/skeletons/MeetingCardSkeleton.tsx` - Loading skeleton component
- `client/src/hooks/useRealtimeMeetings.tsx` - Real-time subscription hook for Client Components
- `client/src/types/meetings.ts` - TypeScript interfaces for meeting data

**Files to Modify:**
- `client/src/app/(main)/page.tsx` - Convert to Server Component with data fetching and Suspense
- `client/package.json` - Add both `appwrite` and `node-appwrite` dependencies

### Testing Requirements

**Testing Strategy [Source: docs/architecture/8-coding-standards.md]:**
- Component tests using Jest and React Testing Library
- Test files located alongside components with `.test.tsx` extension
- Real-time subscription mocking for unit tests
- Integration tests for Appwrite database queries

**Specific Test Cases:**
- MeetingsList renders meetings in chronological order
- MeetingCard displays meeting information correctly
- useMeetings hook manages real-time updates
- Real-time subscriptions update component state
- No duplicate meetings displayed
- Current day filtering works correctly

### Technical Constraints

**Frontend Standards [Source: docs/architecture/8-coding-standards.md]:**
- **TypeScript exclusively** for all frontend code
- **Next.js App Router** with `/src` directory structure
- **Tailwind CSS** for styling (utility-first approach)
- **Appwrite SDK** for database queries and real-time subscriptions
- **SWR or React Query** for data fetching and caching patterns

**Real-time Requirements [Source: docs/architecture/4-frontend-real-time-communication.md]:**
- Real-time updates <2s latency
- Subscribe to relevant Appwrite collections
- Handle connection errors gracefully
- Efficient re-rendering on data updates

**Performance Constraints:**
- Minimize API calls by batching meeting and race queries
- Use React.memo() for meeting cards to prevent unnecessary re-renders
- Implement proper loading states and error handling
- Cache meeting data locally to reduce Appwrite query frequency

### UI/UX Requirements

**Design Patterns:**
- Display meetings as cards or list items
- Show meeting name, country flag, race type, and first race time
- Visual indicators for meeting status (upcoming, live, completed)
- Responsive design for mobile and desktop viewing
- Loading skeletons while data loads
- Empty state when no meetings for current day

**Accessibility:**
- Semantic HTML structure
- ARIA labels for screen readers
- Keyboard navigation support
- Color contrast compliance

### Next.js 15 Performance Optimizations

**Server Components Architecture [Source: Next.js 15 Documentation]:**
- **Primary Data Fetching**: Use Server Components for initial meetings data fetching
- **Reduced Bundle Size**: Server Components run on server, no JavaScript sent to client
- **Optimal Rendering**: Fetch data close to source, render on server for faster initial loads
- **Client Boundaries**: Only use Client Components for real-time subscriptions and interactivity

**Implementation Pattern:**
```typescript
// server/meetings-data.ts - Server Component for initial data
export async function getMeetingsData() {
  const { databases } = await createServerClient();
  return await databases.listDocuments('raceday-db', 'meetings', [
    Query.equal('date', new Date().toISOString().split('T')[0]),
    Query.equal('country', ['AU', 'NZ']),
    Query.orderAsc('$createdAt')
  ]);
}

// app/(main)/page.tsx - Server Component
import { getMeetingsData } from '@/server/meetings-data';
import { MeetingsListClient } from '@/components/dashboard/MeetingsListClient';

export default async function Dashboard() {
  const initialMeetings = await getMeetingsData();
  return <MeetingsListClient initialData={initialMeetings} />;
}
```

**Lazy Loading Strategy [Source: Next.js 15 Performance Guide]:**
- **Dynamic Imports**: Use `next/dynamic` for non-critical components
- **Code Splitting**: Automatic route-based splitting + manual component splitting
- **Progressive Loading**: Load meeting cards progressively as user scrolls

**Implementation Pattern:**
```typescript
// Lazy load heavy components
const MeetingDetailsModal = dynamic(() => import('./MeetingDetailsModal'), {
  loading: () => <div className="animate-pulse bg-gray-200 h-48 rounded" />,
  ssr: false // Client-side only for interactive components
});

// Lazy load meeting cards with intersection observer
const LazyMeetingCard = dynamic(() => import('./MeetingCard'), {
  loading: () => <MeetingCardSkeleton />
});
```

**Appwrite Server vs Client SDK Usage [Source: Appwrite Documentation]:**
- **Server SDK**: Use `node-appwrite` in Server Components for initial data fetching
- **Client SDK**: Use `appwrite` web SDK only in Client Components for real-time subscriptions
- **Security**: API keys stay server-side, sessions handled securely

**Implementation Pattern:**
```typescript
// lib/appwrite-server.ts - Server-side configuration
import { Client, Databases } from 'node-appwrite';

export async function createServerClient() {
  const client = new Client()
    .setEndpoint(process.env.NEXT_PUBLIC_APPWRITE_ENDPOINT!)
    .setProject(process.env.NEXT_PUBLIC_APPWRITE_PROJECT_ID!)
    .setKey(process.env.APPWRITE_API_KEY!); // Server-only API key

  return {
    databases: new Databases(client)
  };
}

// lib/appwrite-client.ts - Client-side configuration  
'use client';
import { Client, Databases } from 'appwrite';

const client = new Client()
  .setEndpoint(process.env.NEXT_PUBLIC_APPWRITE_ENDPOINT!)
  .setProject(process.env.NEXT_PUBLIC_APPWRITE_PROJECT_ID!);

export const databases = new Databases(client);
```

**Caching and Revalidation [Source: Next.js 15 Data Fetching]:**
- **Static Caching**: Use `force-cache` for stable meeting data
- **Time-based Revalidation**: Revalidate meeting data every 5 minutes
- **On-demand Revalidation**: Trigger revalidation when new meetings added

**Implementation Pattern:**
```typescript
// Server Component with caching
export async function getMeetingsData() {
  const { databases } = await createServerClient();
  
  const meetings = await fetch(`${process.env.INTERNAL_API_URL}/meetings`, {
    cache: 'force-cache',
    next: { revalidate: 300 } // 5 minutes
  });
  
  return meetings.json();
}
```

**Streaming and Suspense [Source: Next.js 15 Streaming]:**
- **Progressive Loading**: Stream meetings data as it loads
- **Boundary Management**: Use Suspense boundaries for different data sources
- **Skeleton States**: Show loading skeletons during data fetching

**Implementation Pattern:**
```typescript
// app/(main)/page.tsx with Streaming
import { Suspense } from 'react';
import { MeetingsListSkeleton } from '@/components/skeletons';

export default function Dashboard() {
  return (
    <div>
      <h1>Race Meetings</h1>
      <Suspense fallback={<MeetingsListSkeleton />}>
        <MeetingsServerComponent />
      </Suspense>
    </div>
  );
}
```

**Real-time Performance [Source: Appwrite Real-time Best Practices]:**
- **Selective Subscriptions**: Subscribe only to relevant collections and documents
- **Connection Management**: Handle disconnections gracefully with exponential backoff
- **Update Batching**: Batch rapid updates to prevent UI thrashing

**Implementation Pattern:**
```typescript
// hooks/useRealtimeMeetings.ts
'use client';
export function useRealtimeMeetings(initialData: Meeting[]) {
  const [meetings, setMeetings] = useState(initialData);
  
  useEffect(() => {
    const unsubscribe = client.subscribe([
      'databases.raceday-db.collections.meetings.documents'
    ], (response) => {
      // Batch updates to prevent excessive re-renders
      setMeetings(prev => updateMeetings(prev, response.payload));
    });
    
    return () => unsubscribe();
  }, []);
  
  return meetings;
}
```

**Bundle Optimization [Source: Next.js 15 Bundle Analysis]:**
- **Tree Shaking**: Import only used Appwrite SDK functions
- **Code Splitting**: Split by route and component boundaries
- **Import Analysis**: Use `@next/bundle-analyzer` to monitor bundle size

**Critical Performance Metrics:**
- **Initial Load**: Target <3s for meeting list display
- **Real-time Latency**: <2s for subscription updates
- **Bundle Size**: Client bundle <500KB for dashboard page
- **Lighthouse Score**: Target 90+ for performance

## Tasks / Subtasks

### Task 1: Set up Next.js 15 Optimized Appwrite Configuration (AC: 2)
- [ ] 1.1. Create `client/src/lib/appwrite-server.ts` with Server SDK configuration (node-appwrite)
- [ ] 1.2. Create `client/src/lib/appwrite-client.ts` with Client SDK configuration (appwrite)
- [ ] 1.3. Configure environment variables with server-only API key security
- [ ] 1.4. Add error handling and type safety for both configurations
- [ ] 1.5. Set up proper SDK imports with tree shaking optimization

### Task 2: Create Server Component Data Fetching (AC: 1, 2, 3)
- [ ] 2.1. Create `client/src/server/meetings-data.ts` for Server Component data fetching
- [ ] 2.2. Implement server-side query with caching and revalidation (5-minute cache)
- [ ] 2.3. Add function to get chronologically ordered meetings with first race times
- [ ] 2.4. Implement proper error handling for server-side data fetching
- [ ] 2.5. Add TypeScript interfaces for meeting data structures

### Task 3: Create Real-time Client Hook with Performance Optimization (AC: 1, 2, 3)
- [ ] 3.1. Create `client/src/hooks/useRealtimeMeetings.tsx` for Client Component real-time updates
- [ ] 3.2. Accept initial server data to hydrate client state (Server → Client handoff)
- [ ] 3.3. Implement selective Appwrite real-time subscriptions with connection management
- [ ] 3.4. Add update batching to prevent excessive re-renders during rapid changes
- [ ] 3.5. Implement deduplication logic and chronological sorting
- [ ] 3.6. Add exponential backoff for connection retry logic

### Task 4: Create Optimized Meeting Display Components (AC: 1, 3)
- [ ] 4.1. Create `client/src/components/dashboard/MeetingCard.tsx` with React.memo optimization
- [ ] 4.2. Implement lazy loading with `next/dynamic` for non-critical meeting details
- [ ] 4.3. Add responsive design with Tailwind CSS and performance-optimized classes
- [ ] 4.4. Create loading skeleton component for progressive loading
- [ ] 4.5. Add accessibility features (ARIA labels, semantic HTML, keyboard navigation)

### Task 5: Create Server/Client Hybrid Meetings List (AC: 1, 2, 3)
- [ ] 5.1. Create `client/src/components/dashboard/MeetingsListClient.tsx` (Client Component)
- [ ] 5.2. Accept initial server data as props for instant hydration
- [ ] 5.3. Use useRealtimeMeetings hook for live updates after hydration
- [ ] 5.4. Implement virtualization for large meeting lists (performance optimization)
- [ ] 5.5. Add Suspense boundaries with loading skeletons
- [ ] 5.6. Handle real-time updates with optimistic UI updates

### Task 6: Create Server Component Dashboard Page (AC: 1, 2, 3)
- [ ] 6.1. Update `client/src/app/(main)/page.tsx` as Server Component
- [ ] 6.2. Implement server-side data fetching with getMeetingsData()
- [ ] 6.3. Pass initial data to MeetingsListClient component
- [ ] 6.4. Add Streaming UI with Suspense for progressive loading
- [ ] 6.5. Add metadata generation and SEO optimization
- [ ] 6.6. Ensure responsive layout with proper semantic HTML

### Task 7: Performance-Focused Testing Implementation (Testing Requirements)
- [ ] 7.1. Create unit tests for server-side getMeetingsData with caching validation
- [ ] 7.2. Test useRealtimeMeetings hook with connection retry and batching scenarios
- [ ] 7.3. Create component tests for MeetingCard with React.memo optimization validation
- [ ] 7.4. Test Server Component → Client Component data hydration flow
- [ ] 7.5. Test lazy loading behavior with dynamic imports and intersection observer
- [ ] 7.6. Performance testing: bundle size analysis and Lighthouse scores
- [ ] 7.7. Test real-time subscription handling under rapid update scenarios

### Task 8: Production Performance Optimization (AC: 2)
- [ ] 8.1. Implement React Error Boundaries with fallback UI for graceful degradation
- [ ] 8.2. Add bundle analysis and monitoring with @next/bundle-analyzer
- [ ] 8.3. Implement performance monitoring with Web Vitals and Core Web Vitals tracking
- [ ] 8.4. Add preloading strategies for critical resources and routes
- [ ] 8.5. Validate performance targets: <3s initial load, <500KB bundle, 90+ Lighthouse score

## Testing

**Testing Requirements [Source: docs/architecture/8-coding-standards.md + Next.js 15 Testing]:**

- Test files should be located alongside components with `.test.tsx` extension
- Use Jest and React Testing Library for component testing with Next.js 15 App Router support
- Mock both `appwrite` and `node-appwrite` SDKs for comprehensive unit testing
- Test Server Component data fetching with Next.js testing utilities
- Test Client Component hydration and real-time subscription behavior
- Performance testing: bundle size analysis, Lighthouse CI, Web Vitals monitoring
- Test lazy loading behavior with dynamic imports and intersection observer
- Accessibility tests for keyboard navigation, screen readers, and ARIA compliance

## Change Log

| Date       | Version | Description                                   | Author             |
| ---------- | ------- | --------------------------------------------- | ------------------ |
| 2025-08-02 | 1.0     | Initial story creation with comprehensive technical context | Bob (Scrum Master) |
| 2025-08-02 | 2.0     | Enhanced with Next.js 15 performance optimizations, Server Components, and Appwrite best practices | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
- (To be filled by dev agent)

### Tasks Completed
- (To be filled by dev agent)

### File List
- (To be filled by dev agent)

### Debug Log References
- (To be filled by dev agent)

### Completion Notes
- (To be filled by dev agent)

## QA Results

- (To be filled by QA agent)