After a thorough review of the `prd.md`, `openapi.json`, and `appwrite-setup.txt`, I've identified several key areas for improvement. The provided script is a solid foundation, but it has some critical data-type mismatches, omits required fields for MVP features, and could be optimized for clarity and consistency.

### High-Level Summary of Findings

1.  **Data-Type Mismatches:** Several attributes in the script are defined with a type that doesn't match the source API (e.g., `weight`, `distance`). This would lead to data loss or runtime errors in the polling function.
2.  **Missing MVP Fields:** The script is missing essential fields required for the MVP, such as separate `winOdds` and `placeOdds` for entrants and specific, structured fields for alert configurations.
3.  **Inconsistent Naming:** Attribute names in the script don't always align with the API or standard camelCase conventions, which can cause confusion.
4.  **Redundant Timestamps:** The script creates `createdAt` attributes, which are redundant as Appwrite provides system-generated `$createdAt` and `$updatedAt` fields for all documents.
5.  **Sub-optimal Alert Schema:** The `UserAlertConfigs` schema is too generic and doesn't link alerts to the specific race or entrant they apply to, which is implied by the PRD.

---

### Detailed Collection-by-Collection Analysis & Recommendations

#### 1. `Meetings` Collection
*   **PRD Requirement:** Display meetings, filter by Country and Race Type.
*   **API Data:** `MeetingData` provides `meeting` (ID), `name`, `country`, and `category` ('T', 'H', 'G'). `EventRace` provides a more descriptive `type` ('Thoroughbreds', 'Harness', 'Greyhounds').
*   **Analysis & Recommendation:** The current script is mostly correct. We will align the attribute names to camelCase and use the more descriptive `type` field from the race details for `raceType` to better support the UI.

| Attribute in Script | Recommendation | API Source (`EventRace`) | Justification |
| :--- | :--- | :--- | :--- |
| `meetingIdentifier` | Change to `meetingId` | `meeting_id` | Consistency and clarity. |
| `raceType` | Keep, but populate from `EventRace.type` | `type` | More user-friendly for filtering ('Thoroughbreds' vs 'T'). |
| `meetingDate` | Change to `date` | `advertised_start_string` (of first race) | Simpler name, matches API concept. |
| `venue` | Change to `meetingName` | `meeting_name` | More accurate and consistent. |

#### 2. `Races` Collection
*   **PRD Requirement:** Display race number, name, start time, distance, track condition, and status.
*   **API Data:** `EventRace` schema provides all necessary fields.
*   **Analysis & Recommendation:** There is a critical data-type mismatch for `distance`. The attribute for track condition is ambiguously named.

| Attribute in Script | Recommendation | API Source (`EventRace`) | Justification |
| :--- | :--- | :--- | :--- |
| `raceIdentifier` | Change to `raceId` | `event_id` | Consistency. |
| `startTime` | Keep as is | `advertised_start_string` | Correct. |
| `distance` | **Change type to Integer** | `distance` | **CRITICAL FIX:** API type is `integer`, script is `string`. |
| `track` | Change to `trackCondition` | `track_condition` | Unambiguous naming. |
| `totalPool` | Keep, but note as post-MVP | `tote_pools[?].total` | Good for future use, but not in MVP requirements. |

#### 3. `Entrants` Collection
*   **PRD Requirement:** Display Runner Name, Saddlecloth #, Jockey, Trainer, Win/Place Odds, and Money Flow (`hold_percentage`).
*   **API Data:** `EventRunner` and `EntrantLiability` schemas.
*   **Analysis & Recommendation:** This collection requires the most significant changes. The script is missing separate odds fields, has an incorrect type for `weight`, and uses a generic `status` field instead of the specific `is_scratched` boolean.

| Attribute in Script | Recommendation | API Source (`EventRunner`) | Justification |
| :--- | :--- | :--- | :--- |
| `entrantIdentifier` | Change to `entrantId` | `entrant_id` | Consistency. |
| `horseName` | Change to `name` | `name` | Direct mapping. |
| `number` | Change to `runnerNumber` | `runner_number` | Direct mapping and clarity. |
| `trainer` | Change to `trainerName` | `trainer_name` | Direct mapping and clarity. |
| `weight` | **Change type to String** | `weight.total` | **CRITICAL FIX:** API provides an object with string values, not a float. Storing the `total` string is the simplest, safest mapping. |
| `currentOdds` | **REMOVE** this attribute | N/A | Insufficient for PRD. |
| (new) | **ADD `winOdds` (Float)** | `odds.fixed_win` | **MVP REQUIREMENT:** Required for the data grid. |
| (new) | **ADD `placeOdds` (Float)** | `odds.fixed_place` | **MVP REQUIREMENT:** Required for the data grid. |
| `moneyFlow` | Change to `holdPercentage` | `EntrantLiability.hold_percentage` | Unambiguous naming. |
| `status` | **REMOVE** this attribute | N/A | Too generic. |
| (new) | **ADD `isScratched` (Boolean)** | `is_scratched` | **MVP REQUIREMENT:** Specific, actionable status from the API. |

#### 4. `OddsHistory` Collection
*   **PRD Requirement:** Store a time-series of Win odds for the sparkline chart.
*   **API Data:** `EventRunner.odds.fixed_win`.
*   **Analysis & Recommendation:** The schema is good but can be simplified and made more robust for the future.

| Attribute in Script | Recommendation | API Source | Justification |
| :--- | :--- | :--- | :--- |
| `odds` | Keep as is | `odds.fixed_win` | Correct. |
| `eventTimestamp` | Keep as is | Polling time | Correct. |
| `change` | **REMOVE** this attribute | N/A | The change can be calculated on the fly by the alerting function. Storing it is redundant and complicates inserts. |
| (new) | **ADD `type` (String)** | N/A | Future-proofing to allow storing 'win' or 'place' odds history in the same collection. |

#### 5. `MoneyFlowHistory` Collection
*   **PRD Requirement:** Store a time-series of `hold_percentage`.
*   **Analysis & Recommendation:** Similar to `OddsHistory`, this can be simplified.

| Attribute in Script | Recommendation | API Source (`EntrantLiability`) | Justification |
| :--- | :--- | :--- | :--- |
| `amount` | Change to `holdPercentage` | `hold_percentage` | Clarity and consistency with `entrants` collection. |
| `change` | **REMOVE** this attribute | N/A | Same as `OddsHistory`, change can be calculated when needed. |

#### 6. `UserAlertConfigs` Collection
*   **PRD Requirement:** User can configure alerts for odds/money flow changes from the Detailed Race View.
*   **Analysis & Recommendation:** The current schema is not specific enough. An alert configured on a race view should be tied to a specific entrant. The conditions should be stored as structured data, not a generic string.

| Attribute in Script | Recommendation | Justification |
| :--- | :--- | :--- |
| `userIdentifier` | Change to `userId` (String) | Consistency. |
| `alertType` | Keep, but use enum values like 'odds_change', 'money_flow_change'. | Clarity. |
| `conditions` | **REMOVE** this attribute | Replace with specific, structured fields. |
| (new) | **ADD `entrant` (Relationship)** | **CRITICAL:** Links the alert to the specific entrant it applies to. |
| (new) | **ADD `threshold` (Float)** | Stores the percentage change (e.g., 20.0 for 20%). |
| (new) | **ADD `timeWindowSeconds` (Integer)** | Stores the time window for the alert (e.g., 300 for 5 minutes). Required for odds change alert. |
| `enabled` | Keep as is. | Correct. |
| `createdAt` | **REMOVE** this attribute | Use Appwrite's system `$createdAt` field. |

---

### Revised `appwrite-setup.ts` Script

Here is the updated script incorporating all the recommended changes. Comments highlight the additions and fixes.

```typescript
#!/usr/bin/env node

import { config as loadEnv } from 'dotenv'
import {
  Client,
  Databases,
  Permission,
  Role,
  IndexType,
  RelationshipType,
  ID,
} from 'node-appwrite'

// Load environment variables from .env.local
loadEnv({ path: '.env.local' })

// Configuration
const config = {
  endpoint: process.env.APPWRITE_ENDPOINT || 'https://cloud.appwrite.io/v1',
  projectId: process.env.APPWRITE_PROJECT_ID || '',
  apiKey: process.env.APPWRITE_API_KEY || '',
  databaseId: 'raceday-db',
  collections: {
    meetings: 'meetings',
    races: 'races',
    entrants: 'entrants',
    oddsHistory: 'odds-history',
    moneyFlowHistory: 'money-flow-history',
    userAlertConfigs: 'user-alert-configs',
    notifications: 'notifications',
  },
}

// Initialize Appwrite client
const client = new Client()
  .setEndpoint(config.endpoint)
  .setProject(config.projectId)
  .setKey(config.apiKey)

const databases = new Databases(client)

// --- Utility functions (Unchanged, omitted for brevity) ---
// ... (log, resourceExists, attributeExists, isAttributeAvailable, waitForAttributeAvailable)

// Create database
const createDatabase = async () => {
  log('Creating database...')
  if (await resourceExists(() => databases.get(config.databaseId))) {
    log('Database already exists, skipping.', 'info')
    return
  }
  await databases.create(config.databaseId, 'RaceDay Database', true)
  log('Database created successfully.', 'success')
}

// Create Meetings collection
const createMeetingsCollection = async () => {
  log('Setting up Meetings collection...')
  if (
    !(await resourceExists(() =>
      databases.getCollection(config.databaseId, config.collections.meetings)
    ))
  ) {
    await databases.createCollection(
      config.databaseId,
      config.collections.meetings,
      'Meetings',
      [Permission.read(Role.any())] // Data is public
    )
  }
  // Attributes
  if (!(await attributeExists(config.collections.meetings, 'meetingId'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.meetings, 'meetingId', 50, true);
  }
  if (!(await attributeExists(config.collections.meetings, 'meetingName'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.meetings, 'meetingName', 255, true);
  }
  if (!(await attributeExists(config.collections.meetings, 'country'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.meetings, 'country', 10, true);
  }
  if (!(await attributeExists(config.collections.meetings, 'raceType'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.meetings, 'raceType', 50, true);
  }
  if (!(await attributeExists(config.collections.meetings, 'date'))) {
    await databases.createDatetimeAttribute(config.databaseId, config.collections.meetings, 'date', true);
  }
  if (!(await attributeExists(config.collections.meetings, 'status'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.meetings, 'status', 50, true);
  }
  // Indexes
  // ... (Index creation logic, unchanged, omitted for brevity)
  log('Meetings collection setup complete.', 'success')
}

// Create Races collection
const createRacesCollection = async () => {
  log('Setting up Races collection...')
  if (
    !(await resourceExists(() =>
      databases.getCollection(config.databaseId, config.collections.races)
    ))
  ) {
    await databases.createCollection(
      config.databaseId,
      config.collections.races,
      'Races',
      [Permission.read(Role.any())] // Data is public
    )
  }
  // Attributes
  if (!(await attributeExists(config.collections.races, 'raceId'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.races, 'raceId', 50, true);
  }
  if (!(await attributeExists(config.collections.races, 'name'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.races, 'name', 255, true);
  }
  if (!(await attributeExists(config.collections.races, 'raceNumber'))) {
    await databases.createIntegerAttribute(config.databaseId, config.collections.races, 'raceNumber', true);
  }
  if (!(await attributeExists(config.collections.races, 'startTime'))) {
    await databases.createDatetimeAttribute(config.databaseId, config.collections.races, 'startTime', true);
  }
  // CHANGED: Corrected type from String to Integer to match API
  if (!(await attributeExists(config.collections.races, 'distance'))) {
    await databases.createIntegerAttribute(config.databaseId, config.collections.races, 'distance', false);
  }
  // CHANGED: Renamed for clarity
  if (!(await attributeExists(config.collections.races, 'trackCondition'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.races, 'trackCondition', 100, false);
  }
  if (!(await attributeExists(config.collections.races, 'status'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.races, 'status', 50, true);
  }
  // Relationship
  if (!(await attributeExists(config.collections.races, 'meeting'))) {
      await databases.createRelationshipAttribute(config.databaseId, config.collections.races, config.collections.meetings, RelationshipType.ManyToOne, false, 'meeting', 'races');
  }
  // Indexes
  // ... (Index creation logic, unchanged, omitted for brevity)
  log('Races collection setup complete.', 'success')
}

// Create Entrants collection
const createEntrantsCollection = async () => {
  log('Setting up Entrants collection...')
  if (
    !(await resourceExists(() =>
      databases.getCollection(config.databaseId, config.collections.entrants)
    ))
  ) {
    await databases.createCollection(
      config.databaseId,
      config.collections.entrants,
      'Entrants',
      [Permission.read(Role.any())] // Data is public
    )
  }
  // Attributes
  if (!(await attributeExists(config.collections.entrants, 'entrantId'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.entrants, 'entrantId', 50, true);
  }
  if (!(await attributeExists(config.collections.entrants, 'name'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.entrants, 'name', 255, true);
  }
  if (!(await attributeExists(config.collections.entrants, 'runnerNumber'))) {
    await databases.createIntegerAttribute(config.databaseId, config.collections.entrants, 'runnerNumber', true);
  }
  if (!(await attributeExists(config.collections.entrants, 'jockey'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.entrants, 'jockey', 255, false);
  }
  if (!(await attributeExists(config.collections.entrants, 'trainerName'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.entrants, 'trainerName', 255, false);
  }
  // CHANGED: Corrected type from Float to String to match API
  if (!(await attributeExists(config.collections.entrants, 'weight'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.entrants, 'weight', 50, false);
  }
  // ADDED: New fields for win/place odds to meet PRD requirements
  if (!(await attributeExists(config.collections.entrants, 'winOdds'))) {
    await databases.createFloatAttribute(config.databaseId, config.collections.entrants, 'winOdds', false);
  }
  if (!(await attributeExists(config.collections.entrants, 'placeOdds'))) {
    await databases.createFloatAttribute(config.databaseId, config.collections.entrants, 'placeOdds', false);
  }
  // CHANGED: Renamed for clarity to match API
  if (!(await attributeExists(config.collections.entrants, 'holdPercentage'))) {
    await databases.createFloatAttribute(config.databaseId, config.collections.entrants, 'holdPercentage', false);
  }
  // ADDED: Specific boolean status
  if (!(await attributeExists(config.collections.entrants, 'isScratched'))) {
    await databases.createBooleanAttribute(config.databaseId, config.collections.entrants, 'isScratched', false, false);
  }
  // Relationship
  if (!(await attributeExists(config.collections.entrants, 'race'))) {
    await databases.createRelationshipAttribute(config.databaseId, config.collections.entrants, config.collections.races, RelationshipType.ManyToOne, false, 'race', 'entrants');
  }
  // Indexes
  // ... (Index creation logic, unchanged, omitted for brevity)
  log('Entrants collection setup complete.', 'success')
}

// Create OddsHistory collection
const createOddsHistoryCollection = async () => {
    log('Setting up OddsHistory collection...');
    // ... (collection creation) ...
    // Attributes
    if (!(await attributeExists(config.collections.oddsHistory, 'odds'))) {
        await databases.createFloatAttribute(config.databaseId, config.collections.oddsHistory, 'odds', true);
    }
    if (!(await attributeExists(config.collections.oddsHistory, 'eventTimestamp'))) {
        await databases.createDatetimeAttribute(config.databaseId, config.collections.oddsHistory, 'eventTimestamp', true);
    }
    // ADDED: For future-proofing (e.g. storing place odds history)
    if (!(await attributeExists(config.collections.oddsHistory, 'type'))) {
        await databases.createStringAttribute(config.databaseId, config.collections.oddsHistory, 'type', 20, true, 'win');
    }
    // REMOVED: `change` attribute is redundant
    // Relationship
    if (!(await attributeExists(config.collections.oddsHistory, 'entrant'))) {
        await databases.createRelationshipAttribute(config.databaseId, config.collections.oddsHistory, config.collections.entrants, RelationshipType.ManyToOne, false, 'entrant', 'oddsHistory');
    }
    // ... (index creation) ...
    log('OddsHistory collection setup complete.', 'success');
}

// Create MoneyFlowHistory collection
const createMoneyFlowHistoryCollection = async () => {
    log('Setting up MoneyFlowHistory collection...');
    // ... (collection creation) ...
    // Attributes
    // CHANGED: Renamed for clarity
    if (!(await attributeExists(config.collections.moneyFlowHistory, 'holdPercentage'))) {
        await databases.createFloatAttribute(config.databaseId, config.collections.moneyFlowHistory, 'holdPercentage', true);
    }
    if (!(await attributeExists(config.collections.moneyFlowHistory, 'eventTimestamp'))) {
        await databases.createDatetimeAttribute(config.databaseId, config.collections.moneyFlowHistory, 'eventTimestamp', true);
    }
    // REMOVED: `change` attribute is redundant
    // Relationship
    if (!(await attributeExists(config.collections.moneyFlowHistory, 'entrant'))) {
        await databases.createRelationshipAttribute(config.databaseId, config.collections.moneyFlowHistory, config.collections.entrants, RelationshipType.ManyToOne, false, 'entrant', 'moneyFlowHistory');
    }
    // ... (index creation) ...
    log('MoneyFlowHistory collection setup complete.', 'success');
}


// Create UserAlertConfigs collection
const createUserAlertConfigsCollection = async () => {
  log('Setting up UserAlertConfigs collection...')
  if (
    !(await resourceExists(() =>
      databases.getCollection(
        config.databaseId,
        config.collections.userAlertConfigs
      )
    ))
  ) {
    await databases.createCollection(
      config.databaseId,
      config.collections.userAlertConfigs,
      'UserAlertConfigs',
      // Permissions are per-document, granted to the user who creates it
      [
        Permission.create(Role.users()),
        Permission.read(Role.users()),
        Permission.update(Role.users()),
        Permission.delete(Role.users()),
      ]
    )
  }
  // Attributes
  if (!(await attributeExists(config.collections.userAlertConfigs, 'userId'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.userAlertConfigs, 'userId', 50, true);
  }
  // ADDED: Relationship to link alert to a specific entrant
  if (!(await attributeExists(config.collections.userAlertConfigs, 'entrant'))) {
    await databases.createRelationshipAttribute(config.databaseId, config.collections.userAlertConfigs, config.collections.entrants, RelationshipType.OneToOne, false, 'entrant');
  }
  if (!(await attributeExists(config.collections.userAlertConfigs, 'alertType'))) {
    await databases.createStringAttribute(config.databaseId, config.collections.userAlertConfigs, 'alertType', 50, true);
  }
  // ADDED: Specific, structured fields for alert conditions
  if (!(await attributeExists(config.collections.userAlertConfigs, 'threshold'))) {
    await databases.createFloatAttribute(config.databaseId, config.collections.userAlertConfigs, 'threshold', true);
  }
  if (!(await attributeExists(config.collections.userAlertConfigs, 'timeWindowSeconds'))) {
    await databases.createIntegerAttribute(config.databaseId, config.collections.userAlertConfigs, 'timeWindowSeconds', false);
  }
  if (!(await attributeExists(config.collections.userAlertConfigs, 'enabled'))) {
    await databases.createBooleanAttribute(config.databaseId, config.collections.userAlertConfigs, 'enabled', true);
  }
  // REMOVED: Redundant `createdAt`
  // ... (Index creation) ...
  log('UserAlertConfigs collection setup complete.', 'success')
}


// --- Main setup function (call all creation methods) ---
const setupAppwrite = async () => {
    // ...
}

// ... (Rest of the script is unchanged)
```