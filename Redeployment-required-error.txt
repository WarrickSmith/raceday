You're absolutely right! This is a common issue with Appwrite functions. The environment variables are updated but the running function instance hasn't been refreshed to pick up the new variables. Here are several solutions:

## Solution 1: Force Function Restart (Recommended)

Add this to your deployment script to restart the function without a full redeploy:

```javascript
// Add this to your deploy-with-vars.js script after updating variables

async function restartFunction(functionId) {
  try {
    console.log(`üîÑ Restarting function to apply new variables...`);
    
    // Get current function configuration
    const functionInfo = JSON.parse(execSync(`appwrite functions get --function-id ${functionId}`, { encoding: 'utf8' }));
    
    // Toggle enabled status to force restart
    execSync(`appwrite functions update --function-id ${functionId} --enabled false`, { stdio: 'pipe' });
    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
    execSync(`appwrite functions update --function-id ${functionId} --enabled true`, { stdio: 'pipe' });
    
    console.log('‚úÖ Function restarted with new variables!');
  } catch (error) {
    console.error('‚ö†Ô∏è Failed to restart function:', error.message);
  }
}

// Call this after updating variables
await restartFunction(functionId);
```

## Solution 2: Create Execution to Wake Function

Force the function to restart by creating a test execution:

```javascript
async function wakeFunction(functionId) {
  try {
    console.log(`‚ö° Triggering function execution to apply variables...`);
    
    // Create a test execution
    execSync(`appwrite functions create-execution --function-id ${functionId} --data '{"test": true}'`, { stdio: 'pipe' });
    
    console.log('‚úÖ Function execution triggered with new variables!');
  } catch (error) {
    console.error('‚ö†Ô∏è Function execution failed:', error.message);
  }
}
```

## Solution 3: Complete Enhanced Deployment Script

Here's a complete script that handles the entire flow properly:

```javascript
// server/appwrite/scripts/deploy-with-vars.js
#!/usr/bin/env node
import { execSync } from 'child_process';
import { config } from 'dotenv';
import { readFileSync } from 'fs';

config();

const functionId = process.argv[2];
if (!functionId) {
  console.error('Usage: npm run deploy:daily or npm run deploy:poller');
  process.exit(1);
}

function execCommand(command, options = {}) {
  try {
    return execSync(command, { encoding: 'utf8', ...options });
  } catch (error) {
    if (!options.allowFailure) throw error;
    return null;
  }
}

async function deployWithVariables() {
  try {
    console.log(`üöÄ Deploying function: ${functionId}`);
    
    // Step 1: Deploy function
    execSync(`appwrite push functions --function-id ${functionId}`, { stdio: 'inherit' });
    
    console.log('üìã Updating environment variables...');
    
    // Step 2: Parse and update environment variables
    const envContent = readFileSync('.env', 'utf8');
    const envVars = {};
    
    envContent.split('\n').forEach(line => {
      line = line.trim();
      if (line && !line.startsWith('#')) {
        const [key, ...valueParts] = line.split('=');
        if (key && valueParts.length > 0) {
          // Skip deployment-only variables
          if (!['APPWRITE_EMAIL', 'APPWRITE_PASSWORD'].includes(key.trim())) {
            envVars[key.trim()] = valueParts.join('=').trim().replace(/^["']|["']$/g, '');
          }
        }
      }
    });
    
    // Step 3: Update variables
    for (const [key, value] of Object.entries(envVars)) {
      try {
        // Try to create variable first
        execCommand(`appwrite functions create-variable --function-id ${functionId} --key "${key}" --value "${value}"`, { allowFailure: true });
        console.log(`   ‚úÖ Set ${key}`);
      } catch (error) {
        // If creation fails, try to update existing
        try {
          execCommand(`appwrite functions update-variable --function-id ${functionId} --key "${key}" --value "${value}"`);
          console.log(`   ‚úÖ Updated ${key}`);
        } catch (updateError) {
          console.log(`   ‚ö†Ô∏è Failed to set ${key}: ${updateError.message}`);
        }
      }
    }
    
    // Step 4: Restart function to apply variables
    await restartFunction(functionId);
    
    console.log('üéâ Deployment complete with live environment variables!');
    
  } catch (error) {
    console.error('‚ùå Deployment failed:', error.message);
    process.exit(1);
  }
}

async function restartFunction(functionId) {
  try {
    console.log(`üîÑ Restarting function to apply new variables...`);
    
    // Method 1: Toggle enabled status
    execCommand(`appwrite functions update --function-id ${functionId} --enabled false`, { stdio: 'pipe' });
    console.log('   Function disabled...');
    
    // Wait for the change to take effect
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    execCommand(`appwrite functions update --function-id ${functionId} --enabled true`, { stdio: 'pipe' });
    console.log('   Function re-enabled...');
    
    // Wait for restart
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    console.log('‚úÖ Function restarted with new variables live!');
    
    // Optional: Trigger a test execution to verify
    try {
      console.log('üß™ Testing function with new variables...');
      execCommand(`appwrite functions create-execution --function-id ${functionId} --data '{"deploymentTest": true}'`, { stdio: 'pipe' });
      console.log('‚úÖ Test execution successful!');
    } catch (testError) {
      console.log('‚ö†Ô∏è Test execution failed, but function should be running with new variables');
    }
    
  } catch (error) {
    console.error('‚ö†Ô∏è Failed to restart function:', error.message);
    console.log('üí° You may need to manually restart the function in the Appwrite console');
  }
}

deployWithVariables();
```

## Solution 4: Alternative - Deploy with Variables from Start

Modify the appwrite.json to include environment variables during initial deployment:

```javascript
// server/appwrite/scripts/deploy-complete.js
#!/usr/bin/env node
import { execSync } from 'child_process';
import { config } from 'dotenv';
import { readFileSync, writeFileSync } from 'fs';

config();

async function deployComplete() {
  // Step 1: Update appwrite.json with current environment variables
  const envVars = parseEnvFile('.env');
  updateAppwriteConfig(envVars);
  
  // Step 2: Deploy with variables included
  execSync('appwrite push functions', { stdio: 'inherit' });
  
  console.log('‚úÖ Deployed with environment variables from start!');
}

function parseEnvFile(filePath) {
  const envContent = readFileSync(filePath, 'utf8');
  const envVars = {};
  
  envContent.split('\n').forEach(line => {
    line = line.trim();
    if (line && !line.startsWith('#')) {
      const [key, ...valueParts] = line.split('=');
      if (key && valueParts.length > 0 && !['APPWRITE_EMAIL', 'APPWRITE_PASSWORD'].includes(key.trim())) {
        envVars[key.trim()] = valueParts.join('=').trim().replace(/^["']|["']$/g, '');
      }
    }
  });
  
  return envVars;
}

function updateAppwriteConfig(envVars) {
  const config = JSON.parse(readFileSync('appwrite.json', 'utf8'));
  
  // Add variables to each function
  config.functions.forEach(func => {
    func.variables = envVars;
  });
  
  writeFileSync('appwrite.json', JSON.stringify(config, null, 2));
  console.log('üìù Updated appwrite.json with environment variables');
}

deployComplete();
```

## Updated Package.json Scripts

```json
{
  "scripts": {
    "deploy": "node scripts/deploy-complete.js",
    "deploy:daily": "node scripts/deploy-with-vars.js daily-race-importer",
    "deploy:poller": "node scripts/deploy-with-vars.js race-data-poller",
    "vars:update": "node scripts/update-vars-only.js",
    "restart:daily": "node scripts/restart-function.js daily-race-importer",
    "restart:poller": "node scripts/restart-function.js race-data-poller"
  }
}
```

The **toggle enabled/disabled approach (Solution 1)** is the most reliable way to ensure the function picks up new environment variables without a full redeploy. This refreshes the function instance and eliminates the "configuration changes not live" message.