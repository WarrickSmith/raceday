Yes, there are several ways to update environment variables on active functions without triggering a full redeploy:

## Current Appwrite CLI Capabilities

**Environment variables can be updated independently using the CLI:**

```bash
# Update individual variables
appwrite functions create-variable --function-id daily-race-importer --key "API_KEY" --value "new-value"

# Update multiple variables
appwrite functions update-variable --function-id daily-race-importer --variable-id var123 --value "updated-value"

# List current variables
appwrite functions list-variables --function-id daily-race-importer
```

## Enhanced NPM Script Approach

You can create a deployment script that handles this intelligently:

```javascript
// server/appwrite/scripts/deploy-with-vars.js
#!/usr/bin/env node
import { execSync } from 'child_process';
import { config } from 'dotenv';
import { readFileSync } from 'fs';

config();

const functionId = process.argv[2];
if (!functionId) {
  console.error('Usage: npm run deploy:vars <function-id>');
  process.exit(1);
}

async function deployWithVariables() {
  try {
    console.log(`üöÄ Deploying function: ${functionId}`);
    
    // Deploy function first
    execSync(`appwrite push functions --function-id ${functionId}`, { stdio: 'inherit' });
    
    console.log('üìã Updating environment variables...');
    
    // Parse .env file and update variables individually
    const envContent = readFileSync('.env', 'utf8');
    const envVars = {};
    
    envContent.split('\n').forEach(line => {
      line = line.trim();
      if (line && !line.startsWith('#')) {
        const [key, ...valueParts] = line.split('=');
        if (key && valueParts.length > 0) {
          envVars[key.trim()] = valueParts.join('=').trim().replace(/^["']|["']$/g, '');
        }
      }
    });
    
    // Update variables without redeploying
    for (const [key, value] of Object.entries(envVars)) {
      try {
        // Try to update existing variable
        await execCommand(`appwrite functions update-variable --function-id ${functionId} --key ${key} --value "${value}"`);
        console.log(`   ‚úÖ Updated ${key}`);
      } catch (error) {
        // If update fails, create new variable
        try {
          await execCommand(`appwrite functions create-variable --function-id ${functionId} --key ${key} --value "${value}"`);
          console.log(`   ‚úÖ Created ${key}`);
        } catch (createError) {
          console.log(`   ‚ö†Ô∏è Failed to set ${key}: ${createError.message}`);
        }
      }
    }
    
    console.log('‚úÖ Environment variables updated without redeployment!');
    
  } catch (error) {
    console.error('‚ùå Deployment failed:', error.message);
    process.exit(1);
  }
}

function execCommand(command) {
  return new Promise((resolve, reject) => {
    try {
      execSync(command, { stdio: 'pipe' });
      resolve();
    } catch (error) {
      reject(error);
    }
  });
}

deployWithVariables();
```

## Updated Package.json Scripts

```json
{
  "scripts": {
    "deploy": "appwrite push functions",
    "deploy:daily": "node scripts/deploy-with-vars.js daily-race-importer", 
    "deploy:poller": "node scripts/deploy-with-vars.js race-data-poller",
    "vars:daily": "node scripts/update-vars-only.js daily-race-importer",
    "vars:poller": "node scripts/update-vars-only.js race-data-poller",
    "vars:all": "npm run vars:daily && npm run vars:poller"
  }
}
```

## Variables-Only Update Script

```javascript
// server/appwrite/scripts/update-vars-only.js
#!/usr/bin/env node
import { execSync } from 'child_process';
import { config } from 'dotenv';
import { readFileSync } from 'fs';

config();

const functionId = process.argv[2];
if (!functionId) {
  console.error('Usage: npm run vars:daily or npm run vars:poller');
  process.exit(1);
}

async function updateVariablesOnly() {
  console.log(`üìã Updating environment variables for ${functionId} (no redeploy)...`);
  
  // Parse .env and update variables
  const envContent = readFileSync('.env', 'utf8');
  const envVars = {};
  
  envContent.split('\n').forEach(line => {
    line = line.trim();
    if (line && !line.startsWith('#')) {
      const [key, ...valueParts] = line.split('=');
      if (key && valueParts.length > 0) {
        envVars[key.trim()] = valueParts.join('=').trim().replace(/^["']|["']$/g, '');
      }
    }
  });
  
  for (const [key, value] of Object.entries(envVars)) {
    try {
      execSync(`appwrite functions create-variable --function-id ${functionId} --key ${key} --value "${value}"`, { stdio: 'pipe' });
      console.log(`   ‚úÖ Set ${key}`);
    } catch (error) {
      // Variable might exist, try update
      try {
        execSync(`appwrite functions update-variable --function-id ${functionId} --key ${key} --value "${value}"`, { stdio: 'pipe' });
        console.log(`   ‚úÖ Updated ${key}`);
      } catch (updateError) {
        console.log(`   ‚ö†Ô∏è Failed to set ${key}`);
      }
    }
  }
  
  console.log('‚úÖ Variables updated without function redeployment!');
}

updateVariablesOnly();
```

## Usage Patterns

```bash
# Deploy function AND update variables
npm run deploy:daily

# Update ONLY variables (no redeploy)
npm run vars:daily

# Update variables for all functions
npm run vars:all

# Quick variable updates during development
npm run vars:daily && echo "Variables updated, function still running!"
```

## Key Benefits

1. **Faster updates**: Variable changes take seconds vs minutes for full redeploy
2. **No downtime**: Function keeps running with updated variables
3. **Development efficiency**: Quick iteration on configuration
4. **Selective updates**: Update specific function variables only
5. **Batch operations**: Update all functions' variables at once

This approach lets you deploy functions once and then update variables frequently during development without the overhead of redeployment.